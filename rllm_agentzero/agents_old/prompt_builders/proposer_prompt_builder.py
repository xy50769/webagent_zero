"""
Proposer Prompt Builder
    Build conditional generation prompts for Task Proposer
"""

import logging
from typing import Dict, Optional

logger = logging.getLogger(__name__)


class ProposerPromptBuilder:
    """
    Proposer Prompt Builder
    Build conditional generation prompts for Task Proposer
    """
    
    def __init__(self):
        """Initialize Proposer Prompt Builder"""
        pass
    
    def system_message(self) -> Dict[str, str]:
        """
        Return System Message for Proposer
        Define the role and task generation rules for Proposer
        """
        system_text = (
            "You are a helpful web agent expert and task designer. "
            "Your goal is to propose natural, user-friendly task instructions based on the current webpage context.\n\n"
            "Given:\n"
            "1. The current page content (AxTree)\n"
            "2. A specific target element to interact with\n\n"
            "Generate a concise, high-level user intent (task instruction) that:\n"
            "- Requires interacting with the target element\n"
            "- Sounds like a natural user request\n"
            "- Is feasible but challenging (requires some reasoning)\n"
            "- Follows the Zone of Proximal Development (ZPD) principle: difficult but achievable\n\n"
            "Output ONLY the task instruction, without explanation or additional text."
        )
        
        return {"text": system_text}
    
    def construct_generation_prompt(
        self, 
        obs_axtree: str, 
        target_element: str,
        target_node_id: Optional[str] = None,
        max_axtree_length: int = 8000
    ) -> str:
        """
        Build task generation prompt
        
        Args:
            obs_axtree: Current page AxTree observation
            target_element: Target element description (from edge data)
            target_node_id: Target node ID (optional, for debugging)
            max_axtree_length: Maximum length limit for AxTree
        
        Returns:
            str: Complete User Message
        """
        # Truncate AxTree to prevent exceeding context length
        truncated_axtree = obs_axtree[:max_axtree_length]
        if len(obs_axtree) > max_axtree_length:
            truncated_axtree += "\n... (truncated)"
            logger.debug(f"AxTree truncated from {len(obs_axtree)} to {max_axtree_length} chars")
        
        # Construct User Message
        # Explicitly put Target into Prompt to force model to focus on specific element
        # Conforms to the definition of "Directed Exploration" and "Conditional Generation"
        user_msg = f"Current Page Content (AxTree):\n{truncated_axtree}\n\nTarget Element to Interact With:\n{target_element}\n\nPlease generate a natural user task instruction that requires interacting with the target element."
        
        # If target_node_id is provided, add to log (not added to prompt)
        if target_node_id:
            logger.debug(f"Generating instruction for target node: {target_node_id}")
        
        return user_msg
    
    def parse_instruction(self, raw_output: str) -> str:
        """
        Parse and clean the task instruction generated by LLM
        
        Args:
            raw_output: Original output from LLM
        
        Returns:
            str: Cleaned task instruction
        """
        instruction = raw_output.strip()
        
        # Remove possible prefixes (e.g. "Task:", "Instruction:", etc.)
        prefixes_to_remove = [
            "Task:", 
            "Instruction:", 
            "User Intent:", 
            "Goal:",
            "Task Instruction:",
            "The task is to",
            "The task is:"
        ]
        
        for prefix in prefixes_to_remove:
            if instruction.startswith(prefix):
                instruction = instruction[len(prefix):].strip()
                break
        
        if (instruction.startswith('"') and instruction.endswith('"')) or \
           (instruction.startswith("'") and instruction.endswith("'")):
            instruction = instruction[1:-1].strip()
        
        if not instruction:
            logger.warning("Generated instruction is empty after parsing")
            instruction = "Interact with the specified element"
        
        if instruction and instruction[-1] not in ['.', '!', '?']:
            instruction += '.'
        
        return instruction
    
    def construct_curriculum_explanation(
        self,
        edge_data: Dict,
        horizon_k: int = 1
    ) -> str:
        """
        Build explanation for curriculum selection (for logging and debugging).
        
        Args:
            edge_data: Edge statistics
            horizon_k: Planning horizon
        
        Returns:
            str: Explanation text for curriculum selection
        """
        success = edge_data.get("success", 0)
        total = edge_data.get("total", 0)
        target_element = edge_data.get("target_element", "unknown")
        
        if total == 0:
            p_succ = 0.5
            exploration_status = "unexplored"
        else:
            p_succ = success / total
            if p_succ < 0.3:
                exploration_status = "challenging"
            elif p_succ > 0.7:
                exploration_status = "easy"
            else:
                exploration_status = "optimal ZPD"
        
        explanation = (
            f"Curriculum Selection (K={horizon_k}):\n"
            f"  Target Element: {target_element}\n"
            f"  Success Rate: {p_succ:.2f} ({success}/{total})\n"
            f"  Status: {exploration_status}\n"
        )
        
        if horizon_k > 1:
            explanation += f"  Task Type: Multi-step Planning ({horizon_k} hops)\n"
        else:
            explanation += f"  Task Type: Atomic Operation\n"
        
        return explanation

